var tipuesearch = {"pages": [{'title': 'About', 'text': '課程名稱: 協同產品設計實習 - Collaborative Product Design Practice \n 學員作業網站:\xa0 https://mdecd2025.github.io/hw-scrum-1/ \xa0\xa0 \n 學員作業倉儲:\xa0 https://github.com/mdecd2025/hw-scrum-1 \xa0 \n Solvespace:  https://solvespace.com \n Onshape:  https://onshape.com  學員帳號使用 50703199 At mde \n Webots:  https://cyberbotics.com/ \n AI:\xa0 https://grok.com/ \xa0 \n \n 課程代號: cd2025 \n Teams 線上教學: \n 以 "學號@nfu.edu.tw" 登入 \xa0 https://login.microsoftonline.com/ \xa0 Office 365 \n Teams 團隊代碼:\xa0 p5z4eku \n \n 課程評分: \n Homework (30%) - 每週至少提交兩次與課程進度有關的內容, 完成後填回自評表單 \n Exam (40%) - 建立包含操作流程影片、心得以及提供檔案下載的網頁後填回自評表單 \n Final Report (30%) - 利用網頁內容進行簡報並提交 pdf 格式書面報告, 完成後填回自評表單 \n', 'tags': '', 'url': 'About.html'}, {'title': 'AI', 'text': '\n', 'tags': '', 'url': 'AI.html'}, {'title': 'Server', 'text': '35 - 5j - win10 - Intel(R) Xeon(R) E-2236 CPU @ 3.40GHz\xa0\xa0 3.41 GHz \n cd2025\xa0\xa0\xa0\xa0 8446 \n cdhw\xa0\xa0\xa0\xa0\xa0\xa0\xa0 8445 \n wcm2025 8444 \n wcmhw\xa0\xa0\xa0 8443 \n 1000 - E5200 - win10 - Pentium(R) Dual-Core CPU E5200 @ 2.50GHz \n 9001 - 91 - 9089 - ubuntu - Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz \n 9002 - 91 - 9089 - win10 - Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz \n', 'tags': '', 'url': 'Server.html'}, {'title': 'Tasks', 'text': 'task1 與 task2 任務目的在建立可於近端維護個人作業與協同作業的準備工作: \n task1 (自行製作可攜程式系統) \n task2 (使用 SSH 協定執行作業倉儲的推送) \n task3 與 task4 則為 HW2 的內容之一 \n task3 (使用 Solvespace 建立平面四連桿系統零組件) \n task4 (使用 Onshape 建立平面四連桿系統零組件) \n task5 與 task6 則為 HW3 的主要內容 \n task5 (Webots Tutorial 1 ~3) \n task6 (Webots Tutorial 4 ~6) \n \n', 'tags': '', 'url': 'Tasks.html'}, {'title': 'Wink', 'text': '<!-- 假如檔案小於 5mb, 將 mp4 檔案放入 downloads 目錄後取出 -->\n<div class="winkVideoContainerClass"><video width="1008" height="630" autoplay="autoplay" class="winkVideoClass" controls="controls" data-dirname="/cmsimde/static" data-varname="your_video_unique_name" muted="true">\n<source src="./../downloads/your_video.mp4" type="video/mp4" /></video></div> \n 自行建立可攜 Python 的過程畫面: \n \n \n 使用 SSH 執行 git clone 與 git push 的過程畫面: \n \n \n 設定可攜套件 .gitconfig 的過程畫面: \n \n \n solvespace 零組件繪圖過程畫面: \n \n \n', 'tags': '', 'url': 'Wink.html'}, {'title': 'IPv6', 'text': '已知 w4 之前的學員作業倉儲版本, 無法在 IPv6 位址設定時正確運作, 各學員必須下載  cmsimde_w4.7z , 解開壓縮檔案後, 替換倉儲中的 cmsimde 目錄. \n IPv6 設定: \n 2a 各學員固定 IPv6 分配: 2001:288:6004:17:fff1:cd25:0000:a001 2b 各學員固定 IPv6 分配: 2001:288:6004:17:fff1:cd25:0000:b001 gateway: 2001:288:6004:17::254 dns server:  2001:288:6004:17::3 2001:b000:168::1 \n 2a 以\xa0 w4_2a_index.txt \xa0中的序號為準, 例如: 序號為 1 的學員其固定 IPv6 位址為: \n 2001:288:6004:17:fff1:cd25:0000:a001 \n 若序號為 60 其 IPv6 位址為\xa02001:288:6004:17:fff1:cd25:0000:a060 \n 2b 以\xa0 w4_2b_index.txt \xa0中的序號為準, 例如: 序號為 1 的學員其固定 IPv6 位址為: \n 2001:288:6004:17:fff1:cd25:0000:b001 \n 若序號為 66 其 IPv6 位址為\xa02001:288:6004:17:fff1:cd25:0000:b066 \n 註: 利用 Brython  產生  DNS 伺服器所需的設定. \n 完成 dns 設定之後: \n 2a 序號為 1 的學員其伺服器主機符號名稱為 a1.mde.nfu.edu.tw, 序號 50 則對應 a50. \n 2b 序號為 1 的學員其伺服器主機符號名稱為 b1.mde.nfu.edu.tw, 序號 50 則對應 b50. \n \n 各組員將電腦設為所份配的固定 IPv6 後, 可以利用 python -m http.server, 在作業倉儲中啟動 port 8000 的 http 靜態網頁伺服器, 以下為各班的近端學員靜態網站連結: \n 列出 2a 分組網站與倉儲連結 \n 列出 2b 分組網站與倉儲連結 \n 2a IPv6 port 8000 連線列表 \n 2b IPv6 port 8000 連線列表 \xa0( 列出無法連線學員 ) \n \n 以下為與 AI 系統的對話: \n 請用 Brython 寫出在 id="brython_div1" 嵌入 html 連結的程式. 希望各連結能透過 http 協定連結到班上有 66 位學員的靜態網頁. 其中各學員的固定 IPv6 分別為 2001:288:6004:17:fff1:cd25:0000:b001 到 2001:288:6004:17:fff1:cd25:0000:b066, 且使用 port 8000 進行連結. 請寫出此一 Brython 程式. \n 取得下列程式:  透過 2b 學員序號列出其 IPv6 靜態網站 \n 完成上述以序號標示後, 透過下列詢問可以取得以學號作為標示的各學員近端靜態網站連結. \n 任務一: 請用 Brython 寫出在 id="brython_div1" 嵌入 html 連結的程式. 希望各連結能透過 http 協定連結到班上有 66 位學員的靜態網頁. 其中各學員的固定 IPv6 分別為 2001:288:6004:17:fff1:cd25:0000:b001 到 2001:288:6004:17:fff1:cd25:0000:b066, 且使用 port 8000 進行連結. 請寫出此一 Brython 程式. \n 任務二: 若各學員序號取自 https://mde.tw/cd2025/downloads/w4_2b_index.txt, 且此一資料以空白隔開序號加"." 及學號, 能否修改成以學員的學號作為 html 的標示. \n 任務三: 完成各學員的 html 連結後, 請再用 Brython 程式設法進入每一位學員的網站查驗, 是否可以讀取到該連結 content 目錄中的 About.html, 若可以則 pass, 若無法連結則列出無法完成連結的學員學號. \n 請分別列出上述三個任務的程式碼. \n', 'tags': '', 'url': 'IPv6.html'}, {'title': 'Fossil', 'text': 'Fossil server 與 Git 倉儲結合可以提供協同者參與 Forum 討論, 且在不登入情況下  view Forum . \n 權限設定如下: \n Forum\xa0 \xa0 \xa0/forum\xa0 \xa0 \xa0 \xa0{@2 3 4 5 6}\xa0 \xa0{} \n demo 倉儲與  https://rocket.cycu.org/cdhw  內容同步 \n 經由 proxy server 執行 fossil clone: \n set http_proxy=http://p4.cycu.org:3128\n\nset https_proxy=http://p4.cycu.org:3128\n\nfossil clone https://username@server.name/fossilname fossilname.fossil \n Fossil SCM 的應用 \n https://fossil-scm.org/ \xa0 \n Github 與 Fossil SCM 結合應用範例: \n \n \n Github 與 Fossil 內容整合: \n https://rocket.cycu.org/cdhw/forumpost/61c86299c9', 'tags': '', 'url': 'Fossil.html'}, {'title': 'task1', 'text': '自行製作可攜程式系統 \n 此作業的目的在展示如何利用既有的 Python 可攜系統建立各版本的 Python 可攜環境. \n 以下為操作步驟: \n \n 下載  portable_python311.7z , 展開後是一套尚未安裝 pip 的 Python 3.11 可攜程式環境. \n 雙點擊 portable_python311 目錄中的 start_ipv6.bat 啟動可攜系統, 在 SciTE 中開啟 Y:\\ gen_python313.py , 以下拉式功能表 Tools - Go 執行, 便可在 Y:\\ 建立 Python313 目錄. \n 接著修改 start_ipv6.bat, 利用 Search - Replace, Find 欄位填上 Python311, Replace 欄位填上 Python313 後, 按下 Replace All, 便可將啟動檔中所有 Python311 設定改為 Python313, 另存修改後的檔案為 start_python313.bat. \n 接下來以 stop.bat 關閉 start_ipv6.bat 開啟的可攜系統, 改以心建立的 start_python313.bat 開啟可攜環境, 之後在命令列輸入 python, 確認目前的 Python 版本為 3.13.2 後, 利用 Ctrl + z 退出 Python 後, 利用 pip list 確認目前的 Python 3.13.2 系統尚未配置 pip 模組管理工具. \n 在命令列中, 以 python get-pip.py 安裝 pip 工具, 完成後, 以 pip list 確認 pip.exe 已經配置完成. \n 最後在命令列中, 以 pip install flask flask_cors bs4 lxml pelican markdown 安裝 cmsimde 網際內容管理系統啟動所需的 Python 模組後, 此可攜系統中的 Python 3.13.2 套件已經可以用來維護個人作業倉儲與分組倉儲. \n 之後利用新版的  SciTE ,  Portablegit ,  PUTTY ,  ShareX ,  Wink ,  Solvespace ,  Zoomit ,  ProcessExplorer  以及原有的 tmp 及 home_ipv6, 以新的 start_python313 啟動. \n \n 以下為操作影片: \n \n', 'tags': '', 'url': 'task1.html'}, {'title': 'list', 'text': '以下將要嘗試利用程式方法列出學員的作業倉儲與網頁連結, 以及各分組的倉儲及網站連結. \n 已知的兩段程式 ( 1 ,  2 ), 可以讀取\xa0 https://mde.tw/list/2b.txt \xa0( https://github.com/mdecycu/list ), 並且各學員的學號與\u3000Github 帳號是利用 Tab 隔開. \n 過程中若學員 Github 帳號有更動, 可以透過 Pull Requests 要求修改. \n 以下可直接列出: \n 列出 2a 學員作業網站與倉儲連結 \n 列出 2b 學員作業網站與倉儲連結 \n 列出 2a 分組網站與倉儲連結 \n 列出 2b 分組網站與倉儲連結 \n 目前 cmsimde 使用 Brython 3.12.3, 嘗試更新為 3.12.4 以上版本時, 發現在靜態網頁會與 template chimper 中的 jquery 版本內容衝突, 導致無法從 URL 取下 gist 的 Brython 程式內容. \n 之後可以測試採用 Brython 3.13.2 最新版本, 但在動態與靜態網頁執行 Brython 程式時, 可以將原始碼放入 html 頁面, 並利用 Button 直接進行存取. 可以從  https://github.com/mdecycu/cmsimde_site \xa0建立 Branch 進行測試. \n 題外: \n 下載 Office 2016.iso , 與\xa0 2016_office_kms.bat \xa0from\xa0 https://2019wcm.blogspot.com \xa0 \n 問題:\xa041223144 納入 b 班 g3?? 在 w4 進行移除! \n', 'tags': '', 'url': 'list.html'}, {'title': 'task2', 'text': '使用 SSH 協定執行作業倉儲的推送 \n SSH  是一種加密的網路傳輸協定, PuTTY 則是可用於 Windows 環境的 SSH 協定工具, 其中支援遠端登入 (putty.exe) 與檔案傳輸工具 (psftp.exe). \n 使用 PuTTY 所建立的公私鑰進行 Github push 認證的步驟: \n 第一步: \n 若希望在 Windows 環境透過 git 指令, 使用 PuTTY 設定的 session (一個代表連線伺服器主機、私鑰位置與是否使用代理主機等資訊的字串), 執行 push, 必須要在啟動可攜環境時, 設定 GIT_SSH 環境變數, 將此變數指向 PuTTY 套件中的 plink.exe 位置 (也就是 set GIT_SSH=%Disk%:\\putty\\plink.exe). \n 第二步: \n 指定利用 PuTTY 的 SSH session 執行 git push 後, 必須在 Windows 操作系統中選擇一個字串, 作為 SSH 連線 session 名稱, 由於此設定必須指向 SSH 協定加密用的私鑰所在目錄位置, 因此設定 session 之前, 必須利用 puttygen.txt 建立一對公私鑰, 其中的公鑰為 OpenSSH 格式, 必須送到使用者 Github 帳號設定區 (Settings) 的 SSH and GPG keys 中. \n 第三步: \n 利用 puttygen.exe 建立公私鑰的方法, 是在執行 puttygen.exe 之後, 以滑鼠按下 Generate 之後, 讓滑鼠在 puttgen.exe 視窗中 key 下方的空白區域隨意移動, puttygen.exe 會根據滑鼠移動的位置隨機建立 OpenSSH 格式的公鑰, 以及配對的 PuTTY 格式的 Private Key (副檔名為 .ppk) \n 第四步: \n 接下來, 將 OpenSSH 格式的 Public Key 內容複製到個人 Github 帳號設定區的 SSH and GPG keys 中, 並以 puttygen.exe 執行視窗右下方的 Save private key 按鈕, 將私鑰 (假設為 myprivatekey.ppk) 存至 Y:\\. \n 第五步: \n 接著啟動 PuTTY 中的 putty.exe, 在 Host Name (or IP Address) 欄位填入 github.com, 並確認 Connection Type 選用 SSH, 表示要透過 SSH 加密協定連線到 github.com. \n 第六步: \n 接著在 putty.exe 視窗下方的 Saved Sessions 填入一組字串, 此字串就是之後要遠端登入 github.com 設定 push 連線 URL 的 session 名稱, 在此假設選擇 "mysession" 作為 session 名稱, 使用者可以自行選擇具有代表性的字串, 例如: 學號或簡短的英文姓名縮寫. \n 第七步: \n 在 putty.exe 視窗中填入 github.com 與 "mysession" 名稱之後, 點擊 Save 之後, 此 session 設定就會被 Windows 操作系統存入該台電腦的 Registry 登錄檔案中的 HKEY_CURRENT_USER - SOFTWARE - SimonTatham 所在組態區. 此時可以在命令列中輸入 regedit 後進入登錄檔查看是否 mysession 已經存在. \n 第八步: \n 上列 "mysession" 設定完成且按下 Save 之後, 若再按下 Open, 採用 IPv4 網路連線的電腦應該已經可以透過 putty.exe 遠端連線至 github.com, 視窗中會出現 github.com 作為視窗標題, 且內容為 login as: 但一般使用者並沒有帳號可以直接透過 putty.exe 遠端登入到 github.com, 而只能在 session 設定完成後, 利用此 session 執行 git push. \n 第九步: \n 由於前面的 "mysession" 雖然已經存入 Windows 操作系統的登錄檔, 但並沒有設定 private key 的位置, 因此接下來要再開啟 putty.exe, load 進此一 session, 然後在此 session 設定左方的 Category: 下方的 Connection - SSH - Auth - Credentials 設定中的 Private key file for authentication: 區, 利用 Browse 選擇位於 Y:\\ 的 myprivatekey.ppk 檔案. 選擇檔案完成後, 必須再回到 Catetory: 下方的 Session 區, 以右方的 Save 將附加私鑰位置設定的 session 存檔. 此時 Windows 登錄檔中的 "mysession" 除了代表要使用 SSH 連線到 github.com 之外, 還附帶指定了 myprivatekey.ppk 在 Y:\\ 的位置. \n 第十步: \n 若上述設定是在電腦輔助設計室中的電腦進行, 必須利用命令列 regedit 指令, 進入 HKEY_CURRENT_USER - SOFTWARE - SimonTatham 位置, 利用滑鼠右鍵將此登錄設定檔案"匯出" 存入可攜程式 start_ipv6.bat 所在目錄, 此處假設命名為 mysession.reg, 使用者可以自行對 .reg 命名. \n 第十一步: \n 由於上列的 myprivatekey.ppk 存於可攜程式中的 Y:\\, 因此當使用者利用 start_ipv6.bat 啟動可攜程式後, 就可以利用滑鼠雙點擊位於同目錄的 mysession.reg, 上述的 "mysession" 設定就會存入 Windows 操作系統的登錄檔中. \n 使用 PuTTY session 設定倉儲 .git/config 中的 URL \n 假設上列 "mysession" 對應中的 OpenSSH 格式公鑰是送到 Github 帳號為 scrum-1 學員的 SSH and GPG key 區域, 則 scrum-1 學員在啟動可攜系統後, 已經雙點擊 mysession.reg, 將前述 putty.exe 設定的 session 組態登錄設定回存至 Windows 操作系統中, 則 scrum-1 學員就可以將其近端作業倉儲中的 mysession 用於倉儲 .git/config 檔案的下方設定: \n [remote "origin"]\n    url = git@mysession:mdecd2025/hw-scrum-1.git\n    fetch = +refs/heads/:refs/remotes/origin/ \n 其中的 [remote "origin"] 表示當使用 git 指令中針對此倉儲 "origin" 是一個與遠端倉儲對應的字串代號, 代表其下兩項設定. url 代表此 "origin" 的倉儲連線網址, 而連線至此倉儲的協定是採遠端登入 (使用 Github 支援的 SSH 遠端登入協定), 且此遠端登入的帳號為 "git", 這是所有要使用 SSH 執行 git push 的用戶共同使用的登入帳號. \n url 設定中 "@" 之後的 "mysession" 就是宣告要使用此電腦登錄檔中所設定的 session 名稱 (代表要連線到 github.com, 且帶的 myprivatekey.ppk, 準備在登入流程中與 github.com 中 mdewcm2025 帳號下的 hw-scrum-1 倉儲擁有者 (或帶有 repo 管理權限的帳號) 所登錄的 public keys 進行認證比對, 一旦通過認證, git push 指令就可以成功將改版資料推送到指定的倉儲區域. \n', 'tags': '', 'url': 'task2.html'}, {'title': 'w3', 'text': '列出 2a 學員作業網站與倉儲連結 \n 列出 2b 學員作業網站與倉儲連結 \n 列出 2a 分組網站與倉儲連結 \n 列出 2b 分組網站與倉儲連結 \n \n 請列出各班目前尚未納入分組的學員名單. \n 透過下列程式: \n import os\n# pip install pygithub\nfrom github import Github\n# the following is under IPv6\n# Replace these variables with your own details\nGITHUB_TOKEN = \'your_token\'\nORG_NAME = \'mdecd2025\'\nPROXY = \'http://p4.cycu.org:3128\'\n\ndef get_all_team_members_starting_with_a(org_name, token, proxy):\n    # Set proxy environment variables\n    os.environ[\'http_proxy\'] = proxy\n    os.environ[\'https_proxy\'] = proxy\n\n    # Initialize Github object\n    g = Github(token)\n    all_members = []\n\n    try:\n        # Get organization\n        org = g.get_organization(org_name)\n        \n        # Get all teams\n        teams = org.get_teams()\n        \n        for team in teams:\n            if team.name.lower().startswith(\'g\'):\n                print(f"Processing team: {team.name}")\n                # List members\n                members = team.get_members()\n                for member in members:\n                    all_members.append(member.login)\n                    print(f"Login: {member.login}, ID: {member.id}, URL: {member.html_url}")\n                    \n        print("\\nAll members:", all_members)\n    except Exception as e:\n        print(f"An error occurred: {e}")\n\nif __name__ == "__main__":\n    get_all_team_members_starting_with_a(ORG_NAME, GITHUB_TOKEN, PROXY) \n 已知各班已經參與分組的學員 Github 帳號分別如下: \n a_all_members = [\'41223154\', \'41271125\', \'41271158\', \'41271146\', \'41271131\', \'CYG41223103\', \'41223102\', \'41023128\', \'41023137\', \'41223137\', \'41223157\', \'41223156\', \'otakuyoyo\', \'41223141\', \'41223113\', \'kim41223114\', \'joeisme1208\', \'41223116\', \'41223144\', \'41223140\', \'41223143\', \'41223138\', \'41223134\', \'41223136\', \'zhe41223118\', \'Spirit0224\', \'yuhao-08\', \'41223158\', \'Ren911308\', \'41223150\', \'Manto8\', \'CYA41223106\', \'yan21ed\', \'Lin41223107\', \'41223133\', \'hong41223129\', \'41223110\', \'41223147\', \'Linjiahong41223125\', \'CHN41223132\', \'Yu-Fang-Hong\', \'41023111\', \'yckaooooo\', \'kolas911205\', \'41023105\', \'40932134\', \'41223104\', \'yan41223101\', \'41223105\', \'41223153\', \'41223120\', \'41223152\', \'G8People\', \'WSE41223112\', \'41223146\', \'41223119\']\nb_all_members = [\'41223251\', \'41223211\', \'41223245\', \'41223243\', \'jjjay41223212\', \'leeshaowei0716\', \'41223234\', \'41223209\', \'41223205\', \'41223201\', \'41223202\', \'41223208-hw\', \'41223216\', \'41223217\', \'41223248\', \'emma0312\', \'41223242\', \'41223203\', \'41223144\', \'41223235\', \'RAY41223215\', \'hyy41223228\', \'41223227\', \'41223206\', \'41223226-0\', \'Cloud41223237\', \'Yujenchuang\', \'41223225\', \'ljg41223220\', \'supowen\', \'jacky93111\', \'41223246\', \'Liu41223244\', \'41223236\', \'41223219\', \'41271237\', \'41223249\', \'41223229\', \'41223224\', \'41223222\', \'41223231\', \'linryan23\', \'41023114\', \'41223230\', \'timluo123\', \'CYC41223247\', \'41223218\', \'ych0227\', \'41023215\', \'41023216\', \'41023213\', \'41071203\', \'41071204\', \'41071202\', \'c-ching\', \'YUN4\', \'tseYU000\', \'snowfall-killer\', \'junpig10\'] \n 請接著列出目前各班尚未納組的學員學號. \n 首先看能否從 list\\2a.txt  讀出學員的學號與 github 帳號 : \n # 建立 url 變數與網站中 2a 學員的學號與帳號資料 URL 網誌字串對應\nurl = "https://mde.tw/list/2a.txt"\n# 利用 open() 物件中的 readlines() 方法, 取出網站中的資料並逐行放入數列中, 因此 data 的資料型別為數列\ndata = open(url).readlines()\n# 進行資料查驗時, 印出 data 數列內容\n#print(data)\n# 因為學員資料中的第一列為標題, 因此有效資料從索引值 1 開始\nall_stud = data[1:]\n# 確定已經取得 2a.txt 中的學號與 github 帳號資料\n#print(all_stud)\n# 利用 for 迴圈逐一列出各學員的單行資料\n# 已知各行資料是以 \\n 跳行, 可以設法先刪除每一筆資料最後的跳行符號\nfor i in all_stud:\n    #print(i)\n    drop_n = i.rstrip("\\n")\n    # 確定每一行最後的跳行符號已經移除\n    #print(drop_n, end="")\n    # 設法利用學號與帳號間的 "\\t" 將資料隔開\n    stud = drop_n.split("\\t")\n    #print(stud)\n    stud_num = stud[0]\n    stud_github = stud[1]\n    print("學號為 ", stud_num, " 的學員, 其 Github 帳號為 ", stud[1]) \n 只要在迴圈中加入下列判斷式: \n #print("學號為 ", stud_num, " 的學員, 其 Github 帳號為 ", stud[1])\nif stud_github not in a_all_members:\n    print(stud_num) \n 即可取得下列尚未納組的學員學號: \n 2a : \n 41023220 41223111 41223119 41223124 41223148 \n 2b : \n 40923137 41023237 41223210 41223214 41223223 41223232 41223233 41223239 41223245 41271217 41271236 \n \n \n', 'tags': '', 'url': 'w3.html'}, {'title': 'task3', 'text': '使用 Solvespace 建立平面四連桿系統零組件 (HW2) \n fourbar_slvs.7z \n', 'tags': '', 'url': 'task3.html'}, {'title': 'task4', 'text': '原先想法: \n 因為隨後可以透過比對取得尚未納組的學員 Github 帳號, 且必須設法從其 Github 帳號, 取得其對應學號, 因此若能從上列程式設法建立一個 Dict, 支援輸入 Github\xa0 帳號可以回覆其對應學號, 就可以順利找出目前尚未納組的學員學號. 另外是否也必須查驗是否有學員加入錯誤的班級組別? \n 實際解法: \n 因為上列程式已經給出兩班當時已經參與分組的學員 Github 帳號, 因此只需要從  https://mde.tw/list/2b.txt \xa0讀取學員的學號與 Github 帳號, 並且在 for 迴圈中, 逐一用學員的 Github 帳號相對於各班已經參與分組的學員 Github 帳號, 並且列出特定學員的 Github 帳號不在前述已經參與分組的學員帳號數列中, 即可列出截至當時尚未那組的學員學號. \n', 'tags': '', 'url': 'task4.html'}, {'title': 'w4', 'text': '已知目前的學員作業倉儲無法在 IPv6 位址設定時正確運作, 各學員必須下載  cmsimde_w4.7z , 解開壓縮檔案後, 替換倉儲中的 cmsimde 目錄. \n 開始建立 Webots 模擬場景:  w4 開始的練習 \n 為什麼建立 Webots 場景需要先建立 Robot 物件? \n 在 Webots 中，建立場景時需要先建立一個 Robot 物件的原因，與 Webots 的模擬架構和工作原理密切相關。以下是詳細解釋： \n 1. Webots 的核心設計理念 Webots 是一個用於模擬機器人行為的平台，它的場景（world）是由多個物件（nodes）組成的樹狀結構。而 Robot 物件是一個特殊的節點（node），它不僅代表一個實體機器人，還承載了與模擬環境交互的核心功能，例如感測器、執行器和控制器。沒有 Robot 物件，場景就缺少一個主體來執行具體的任務或行為，模擬也就失去了意義。 \n 2. Robot 物件的功能 \xa0\xa0\xa0 控制器綁定：每個 Robot 物件都需要指定一個控制器（controller），這是用來定義機器人行為的程式（可以用 C、C++、Python 等語言編寫）。沒有 Robot，就無法運行控制器，也無法模擬機器人的動作或決策。 \xa0\xa0\xa0 感測器與執行器：Robot 物件是感測器（例如攝影機、距離感測器）和執行器（例如馬達、輪子）的容器。這些設備必須依附於一個 Robot 節點才能運作。 \xa0\xa0\xa0 物理屬性：Robot 物件定義了機器人在模擬環境中的物理存在，例如位置、質量和形狀。如果沒有這個物件，場景中就沒有可以與物理引擎交互的實體。 3. 場景的結構要求 在 Webots 中，場景檔案（.wbt 檔案）是一個層次化的描述，所有的節點都必須遵循一定的語法規則。Robot 節點通常作為場景中的頂層節點之一，直接或間接連接到根節點（World）。如果沒有 Robot，場景可能只包含靜態物件（例如牆壁或地板），但無法進行動態模擬，因為缺少能夠主動參與模擬的實體。 \n 4. 實際操作中的必要性 當你建立一個 Webots 場景時，通常的目的是模擬某個機器人的行為（例如移動、避障、抓取物品等）。因此，第一步通常是定義一個 Robot 物件，然後在這個物件下添加必要的子節點（例如 DifferentialWheels、感測器等），以實現模擬目標。換句話說，Robot 是場景的起點，沒有它，後續的配置就無從談起。 \n 總結 建立 Webots 場景需要先建立 Robot 物件，因為它是模擬的核心實體，承載了控制器、感測器、執行器和物理屬性等功能。沒有 Robot，場景就只是一個靜態的環境，無法實現動態的機器人模擬。這是 Webots 設計上的基本要求，也是模擬流程的邏輯起點。 \n Webots 在建立連桿機構模型時, 是否無法建立 closed chain 機構的 kinematics 模型, 只能建立 dynamic model? \n 在 Webots 中，建立連桿機構模型時，的確有一些限制。Webots 是一個仿真軟體，主要用於機器人和機械系統的動態仿真，並且使用的模型大多是基於動態模型（dynamic models）來進行運算和仿真。對於一個閉環機構（closed-chain mechanism），Webots 不提供直接建立其運動學（kinematics）模型的工具或算法。 \n 1. 關於閉環機構的幾點說明： \xa0\xa0\xa0 運動學（Kinematics）是描述機構運動的幾何學模型，通常關注的是位置、速度和加速度等。 \xa0\xa0\xa0 動力學（Dynamics）則是考慮外力、慣性、摩擦等物理因素，描述機構在運動過程中的力學行為。 2. Webots 中的模型類型： \xa0\xa0\xa0 Webots 主要依賴動力學模型來處理仿真，這些模型包括力學運算、質量、慣性矩等。在處理一個閉環機構（例如機械手臂中帶有閉環結構的部分）時，Webots 更加強調的是系統的運動學和動力學的結合，並通過數值積分來解決動態方程，而不是像一些其他專門的運動學求解軟體（如 MATLAB、Adams 等）一樣單獨進行運動學建模。 3. 關於閉環機構的仿真： \xa0\xa0\xa0 當建立閉環機構模型時，Webots 並不直接提供基於閉環運動學的求解器。相反，Webots 會通過動態模型，並將閉環運動的約束作為力學條件來進行處理。因此，它會基於質量、力和慣性等動態特徵來解算運動。 \xa0\xa0\xa0 若需要精確的運動學建模，可以考慮在外部工具中（如 MATLAB、Simulink 或 ROS）進行運動學建模，再將結果導入到 Webots 進行動態仿真。 總結： Webots 在處理閉環機構時，主要側重於動力學模型的建立，而不是運動學模型。它能夠處理閉環結構的動態行為，但不直接提供基於運動學的閉環求解。對於複雜的運動學分析，可能需要借助其他專業工具來處理，然後將結果匯入 Webots 進行仿真。 \n 請就此點與 CoppeliaSim 建模進行比較 \n 在建模閉環機構（closed-chain mechanism）時， CoppeliaSim （原名 V-REP）和  Webots  之間的區別主要體現在它們對運動學（kinematics）和動力學（dynamics）的處理方式上。 \n Webots 的建模特點： \n \n \n 動力學為主 ： \n \n Webots 強調的是機構的動力學模型，通過質量、慣性矩、力學約束等來描述機構的運動。當處理閉環機構時，Webots 並不直接提供運動學的求解過程，而是依賴動力學來解決運動方程。 \n 它的仿真是基於數值積分的動態仿真，並且處理的是物理層面上的相互作用，這意味著它更多地側重於如何模擬機構的動力學行為（如速度、加速度、力等）而非僅僅描述機構的幾何運動。 \n 在設計複雜的閉環機構時，通常需要考慮機構的運動限制，這些限制會作為力學約束條件（例如接觸力、摩擦力、鉸鏈等）納入動力學模型中來進行仿真。 \n \n \n \n 閉環機構的動態仿真 ： \n \n Webots 不能直接生成閉環機構的運動學模型（例如雅可比矩陣、運動方程），但它可以處理這些機構的動力學模型並通過數值方法解算運動。閉環機構的運動限制通常會通過編程或物理約束來處理。 \n \n \n \n CoppeliaSim 的建模特點： \n \n \n 強調運動學與動力學結合 ： \n \n CoppeliaSim 在處理閉環機構時，與 Webots 類似，主要處理的是機構的 動力學仿真 ，但它同時也具備更強大的 運動學分析功能 。它支持基於機構運動學的建模，並且能夠生成雅可比矩陣、運動學方程等。 \n 在 CoppeliaSim 中，可以直接利用其內建的運動學求解器來處理複雜的運動學問題（例如多自由度機械手臂、閉環機構等），這使得它能夠提供精確的運動學分析，並且可以基於這些分析結果進行動態仿真。 \n \n \n \n 運動學建模和約束處理 ： \n \n CoppeliaSim 允許在機構建模過程中使用 運動學約束 來定義閉環結構。這意味著，使用者可以明確地定義機構的各個部件如何運動、約束其位置、速度等，甚至可以設置關節限制、碰撞檢測等。這些運動學約束和幾何關係被用來確保機構在仿真過程中遵循合理的運動軌跡。 \n CoppeliaSim 提供了許多現成的機構建模元件，如彈簧、齒輪、連桿等，並支持用戶自定義機構和關節的運動學約束。 \n \n \n \n 更多的控制和交互性 ： \n \n CoppeliaSim 提供了豐富的控制接口，並支持與外部系統進行聯動（如 ROS、Python 等）。這使得用戶可以實現對閉環機構的控制，並將控制策略與運動學和動力學仿真結合起來。 \n 它也提供了反向運動學（Inverse Kinematics, IK）解算器，對於機械手臂等應用，能夠簡化運動學的建模過程。 \n \n \n \n 總結比較： \n \n \n \n 特性 \n Webots \n CoppeliaSim \n \n \n \n \n 建模重點 \n 動力學仿真為主，基於物理規則計算運動 \n 結合運動學與動力學，提供更高層次的建模功能 \n \n \n 運動學分析 \n 不直接處理運動學，基於動力學解算運動 \n 提供運動學求解器，支持雅可比矩陣和運動方程 \n \n \n 閉環機構處理 \n 需要通過物理約束來實現 \n 可通過運動學約束和動力學約束建模閉環機構 \n \n \n 運動學求解器 \n 不提供運動學求解器 \n 提供運動學求解器，支持反向運動學解算 \n \n \n 開發與控制接口 \n 支持與外部控制系統連接（如 ROS） \n 支持多種控制接口，易於與外部系統集成 \n \n \n 易用性與功能豐富度 \n 偏向於動力學仿真，適合模擬機器人運動 \n 提供完整的運動學和動力學建模，適合精細建模 \n \n \n \n 結論： \n \n 如果你專注於 動態仿真 ，並且希望更強調機構的物理交互， Webots  是一個很好的選擇。 \n 如果你需要一個結合 運動學與動力學 的工具，並且希望進行更精細的機構建模， CoppeliaSim  提供了更多的功能來處理閉環機構的運動學約束和動力學行為。它對於處理複雜的運動學問題（例如逆運動學）以及閉環機構的建模可能更加靈活。 \n \n 因此，選擇哪個平台取決於你的具體需求，如果你需要較高層次的運動學建模，CoppeliaSim 可能更適合；如果重點在於機構的動態仿真和控制，Webots 可能是更好的選擇。 \n \n 使用 Onshape 建立平面四連桿系統零組件 (HW2) \n 連桿尺寸依據:  fourbar_slvs.7z \n', 'tags': '', 'url': 'w4.html'}, {'title': 'w5', 'text': '內容一: \n cadlab 網路設定範例:\xa0 account_network_setup.7z \n \n 內容二: \n 接下來, 我們將說明如何在 Webots 中利用簡單的 box 物件建立 link, 利用 HingeJoint 建立 旋轉軸, 並且利用 Python controller 程式控制 link 的旋轉, 以下的模擬場景為可分別針對 link1, link2, link3 控制旋轉的 Open chain 運動模型, 請各組接續完成 Closed chain 的 box 四連桿運動場景. 完成後請詳細說明各連接桿與連接軸的設定步驟, 將說明以及操作影片分別放入個人與分組的倉儲及網頁中. \n cd2025_box_fourbar.zip \n 平面四連桿的尺寸設計: 固定桿長度為 1m, 主動旋轉桿長度為 0.4m, 第二旋轉桿長度為 0.6m, 第三旋轉桿長度為 0.9m. \n 工具: Webots R2025a, Solvespace 3.1, Python 3.13.2, 可攜程式環境 wcm2025 \n 希望完成的模擬結果如下: \n \n https://cyberbotics.com/doc/guide/introduction-to-webots \xa0 \n What is Webots? \n Webots is a professional mobile robot simulation software package. It offers a rapid prototyping environment, that allows the user to create 3D virtual worlds with physics properties such as mass, joints, friction coefficients, etc. \n The user can add simple passive objects or active objects called mobile robots. These robots can have different locomotion schemes (wheeled robots, legged robots, or flying robots). Moreover, they may be equipped with a number of sensor and actuator devices, such as distance sensors, drive wheels, cameras, motors, touch sensors, emitters, receivers, etc. \n Finally, the user can program each robot individually to exhibit the desired behavior. Webots contains a large number of robot models and controller program examples to help users get started. \n Webots also contains a number of interfaces to real mobile robots, so that once your simulated robot behaves as expected, you can transfer its control program to a real robot like e-puck, DARwIn-OP, Nao, etc. Adding new interfaces is possible through the related system. \n Webots Simulation: \n A Webots simulation is composed of following items: \n A Webots world file (.wbt) that defines one or several robots and their environment. The .wbt file does sometimes depend on external PROTO files (.proto) and textures. \n One or several controller programs for the above robots (in C/C++/Java/Python/MATLAB). \n An optional physics plugin that can be used to modify Webots regular physics behavior (in C/C++). \n What is a world? \n A world, in Webots, is a 3D description of the properties of robots and of their environment. It contains a description of every object: position, orientation, geometry, appearance (like color or brightness), physical properties, type of object, etc. \n Worlds are organized as hierarchical structures where objects can contain other objects (like in VRML97). \n For example, a robot can contain two wheels, a distance sensor and a joint which itself contains a camera, etc. \n A world file doesn\'t contain the controller code of the robots; it only specifies the name of the controller that is required for each robot. Worlds are saved in ".wbt" files. The ".wbt" files are stored in the "worlds" subdirectory of each Webots project. \n What is a Controller? \n A controller is a computer program that controls a robot specified in a world file. \n Controllers can be written in any of the programming languages supported by Webots: C, C++, Java, Python or MATLAB. \n When a simulation starts, Webots launches the specified controllers, each as a separate process, and it associates the controller processes with the simulated robots. \n Note that several robots can use the same controller code, however a distinct process will be launched for each robot. \n Some programming languages need to be compiled (C and C++) other languages need to be interpreted (Python and MATLAB) and some need to be both compiled and interpreted (Java). \n For example, C and C++ controllers are compiled to platform-dependent binary executables (for example ".exe" under Windows). \n Python and MATLAB controllers are interpreted by the corresponding run-time systems (which must be installed). \n Java controller need to be compiled to byte code (".class" files or ".jar") and then interpreted by a Java Virtual Machine. \n The source files and binary files of each controller are stored together in a controller directory. A controller directory is placed in the "controllers" subdirectory of each Webots project. \n What is a Supervisor Controller? \n The Supervisor controller is the controller of a Robot whose supervisor field is set to TRUE, it can execute operations that can normally only be carried out by a human operator and not by a real robot. \n The Supervisor controller can be written in any of the above mentioned programming languages. However, in contrast with a regular Robot controller, the Supervisor controller will have access to privileged operations. The privileged operations include simulation control, for example, moving the robots to a random position, making a video capture of the simulation, etc. \n Starting Webots: \n start.bat contains setup for Webots: \n REM for Webots set PYTHON_PATH=%Disk%:\\ Python313 \n REM for webots set  path_webots =%Disk%:\\ Webots_2025a \\msys64\\mingw64\\bin;%Disk%:\\Webots_2025a\\msys64\\usr\\bin \n path=%Disk%:;%path_python%;%path_git%;%path_copsim%;%path_msys2%;%path_miketex%;%path_flutter%;%path_node%;%path_tcc%;%path_postgresql%;%path_range%;%path_lua%;%path_core%;%path_putty%;%path_vscode%;%RUST_PATH%;%path_erlang%;%path_nodejs%;%path_haskell%;%path_scite%;%path_xsltproc%;%path_gnuplot%;%path_openssl%;%path_poppler%; %path_webots% ;%path_blender%;%path%; \n Therefore, under portable system dos windows, key in "webotsw" to start Webots. \n User Interface: \n https://cyberbotics.com/doc/guide/the-user-interface \xa0 \n w5_boomer.7z \n fourbar_box.7z \n 1. \n \n 2. \n \n 3. \n \n 4. \n \n 5. \n \n 6. \n \n 7. \n \n 8. \n \n 對 link1 施以 Torque 的 box 四連桿模擬場景與控制程式:\xa0 cd2025_box_fourbar_w5.7z \n fourbar_box_w5.7z \n', 'tags': '', 'url': 'w5.html'}, {'title': 'w6', 'text': 'basket_ball_shooter.7z \n basket_ball_shooter_w7.7z \n \n tutorial5.7z \n 以下為利用多個 Shape 以 Group 組合為一個 boundingObject 複合外形, 以作為後續碰撞檢測用. 相關架構如下: \n \n \n 請注意, 所有 world 的存檔必須要將模擬時間轉為 0 , 否則所存的變數狀態將為該時間的模擬結果. \n Tutorial 1  重點摘要: \n 將\xa0 Webots_2025a_web.7z \xa0解開壓縮後放入可攜套件 ( portable_wcm2025.7z ) 的 data 目錄中. \n 因為 start.bat 中已經宣告 Python 所在位置, 並將執行 webotsw.exe 所在的目錄放入 Windows 的命令搜尋路徑變數中 (path). \n REM for Webots\nset PYTHON_PATH=%Disk%:\\Python313\n\nREM for webots\nset  path_webots=%Disk%:\\Webots_2025a\\msys64\\mingw64\\bin;%Disk%:\\Webots_2025a\\msys64\\usr\\bin \n 當起始一個 Webots project, 需要至少建立 worlds、controllers、protos 等三個目錄, 而且 Robot 的 控制器程式必須放入 controllers 目錄, 且控制程式檔名必須與子目錄相同 . \n Tutorial 2  重點摘要: \n \n 根據上圖, 在  Webots 建立剛體物件, 必須使用 Solid 節點, 並從節點中的 children 建立 Shape 後宣告其 geometry 外形用於系統的運動方程式, 而其碰撞檢測的外形依據, 則從 Solid 節點的 boundingObject 中的 geometry 進行確認 . \n 另外可從 View - Optional Rendering - Show coordinate system 選項, 要求系統列出目前視圖所依據的座標系統. \n 當在 base 物件建立旋轉軸時, HingeJoint 物件的位階必須與 base 相同, 而且 link1 的 solid 物件必須接在 HingeJoint 的 endPoint 節點上, 且因為 link1 的最後位置並非位於其旋轉中心, 因此在建立 link1 solid 物件下的 shape 之前必須先使用 pose 物件, 以便在 solid 的 parent 座標系統之下, 建立一個屬於 shape 的局部座標轉換系統. \n 另外 HingeJoint 的旋轉中心位置是由 jointParameters 物件下的 anchor 欄位決定, 而其旋轉軸則由 axis 欄位決定. \n 由於 link1 最後需要透過碰撞檢測來與籃球互動, 因此除了 dynamic simulation 之外, 還需要設定 boundingObject, 才能界定 link1 的碰撞幾何外形, 但由於前面的 link1 並非在其 parent 座標系統的物件中心旋轉, 而是透過其局部座標轉換 (利用 pose 物件達成), 往局部 x 方向移動 0.2m, 因此 boundingObject 在引用其 shape 時, 也必須透過 pose 轉換到 link1 最終所在位置. \n 上列流程所完成的 Webots 專案檔:\xa0 w6_demo_project.7z \xa0(joint on link1) \n w6_joint_on_base_project.7z \xa0(joint on base) \n \n', 'tags': '', 'url': 'w6.html'}, {'title': 'task5', 'text': 'Webots Tutorial 1 ~3 (HW3) \n https://cyberbotics.com/doc/guide/introduction-to-webots \n \n 請用繁體中文詳細說明下列資料:  https://cyberbotics.com/doc/guide/introduction-to-webots\xa0 \n 請整理  https://cyberbotics.com/doc/guide/introduction-to-webots  中重要的英文單字與用法, 並且針對其中所使用的英文文法逐句說明. \n 請摘要出下列內容: (放入英文文章內容) \n 請列出上述文章中的重要的英文單字與解釋, 以及出現在文句中的用法: \n 請詳細說明如何採手動方式在 Webots 建立下列場景: \n 希望可以手把手一步步說明該如何利用圖形介面 menu 建立這個場景, 過程中有那些要點必須特別注意? \n \n', 'tags': '', 'url': 'task5.html'}, {'title': 'w7', 'text': '先下載\xa0 fourbar_box.7z , 以便作為建立模擬場景的參考. \n 啟動可攜套件中的 Webots: \n start.bat 中已經安排以下的設定: \n REM for Webots\nset PYTHON_PATH=%Disk%:\\Python313\n\nREM for webots\nset  path_webots=%Disk%:\\Webots_2025a\\msys64\\mingw64\\bin;%Disk%:\\Webots_2025a\\msys64\\usr\\bin\n\npath=%Disk%:;%path_python%;%path_git%;%path_copsim%;%path_msys2%;%path_miketex%;%path_flutter%;%path_node%;%path_tcc%;%path_postgresql%;%path_range%;%path_lua%;%path_core%;%path_putty%;%path_vscode%;%RUST_PATH%;%path_erlang%;%path_nodejs%;%path_haskell%;%path_scite%;%path_xsltproc%;%path_gnuplot%;%path_openssl%;%path_poppler%;%path_webots%;%path_blender%;%path%; \n 只要 Webots_2025a 位於可攜套件的 data 目錄下, 啟動可攜系統之後就可輸入 webotsw 開啟套件. \n 建立 fourbar box 過程中的要點: \n \n 各 Solid - Shape - geometry 在建立 open chain 機構時, 可以在尚未設定 physics 之前單軸運轉, 但 Webots 牽涉需要模擬 closed chain 機構時, 各 Solid - Shape -geometry 則必須設定 boundingObject 與 physics 才能透過 solidReference 進行 dynamics 聯立運算. 亦即 Webots 在模擬封閉機構時, 只能處理 Dynamics 模擬, 原因是其模擬運算是從  ODE  動力程式庫修改而來, 並沒有附加 closed chain 的 kinematics 運算. \n 當個別 link 採 box 建立時, 為了要符合其 kinematics 運動約束條件, 各桿件的起始條件必須滿足 fourbar linkage 的約束條件, 因此只有 link1 旋轉 90 度, 可以在 x 與 y 軸同動的情況下無需透 pose 進行局部座標轉換, 但 link2 與 link3 在納入 Shape 之前必須立 pose 節點置入額外的座標轉換. \n 各 link 的 boundingObject 欄位, 可以透過其 link Shape 採 USE 的方式重用. \n 最後 joint4 的旋轉中心則透過 solidReference 與 link3 的端點座標重合, 才能完成 closed chain 的動力約束條件模擬. \n 所完成的 fourbar box 運動場景:\xa0 w7_2b_fourbar_box.7z \n \n \n fourbar_shooter_w7.7z \n fourbar_shooter_w7-2.7z', 'tags': '', 'url': 'w7.html'}, {'title': 'w8', 'text': '根據  SolidReference  節點的用法說明, SolidReference 可以用在 Joint 節點的 endPoint 欄位中，用來指向一個現有的 Solid 或靜態環境 <static environment>。通過這種方式，可以閉合機械迴圈。 \n 當指向一個 Solid 時，唯一的限制是 Solid 和 Joint 必須是某個共同上層 Solid 的後代。 \n 意思即, SolidReference 是一個引用類型，允許在 Joint 節點的 endPoint 欄位中指定某個目標。它可以指向兩種類型的對象： \n \n 現有的 Solid：這是一個具體的實體（例如某個機械零件或組件），但這個 Solid 和 Joint 必須是某個共同上層 Solid 的後代。 \n 靜態環境 <static environment>：這通常指的是不動的參考框架（例如地面或固定基座）。 \n \n 根據第一個情況，若將 fourbar linkage 的 joint4 設置在 base link 的最右端，然後將 joint4 的 endPoint 欄位，設為 SolidReference 指向 link3，即可符合 Soild (link3) 與 Joint (joint4) 都是某個共同上層 Solid (base) 的後代。 \n 至於第二個情況，則可以將 fourbar linkage 的 joint4 設置在 link3 的末端，然後將 joint4 的 endPoint 欄位指向 <static environment>，讓 link3 的末端固定在 ground (其作用與固定在 base 節點相同)。 \n fourbar box 四連桿機構: \n fourbar_box.7z  的  SolidReference  採用第一種作法，joint4 位於 base link，然後參照指向 link3。 \n fourbar_box_w8.7z \xa0(將 joint4 接在 link3 末端，然後\xa0 SolidReference  參照到內定的 <static environment>， 表示將 link3 末端的 joint4 直接固定在 base 上 (固定點)。 \n fourbar solvespace 四連桿機構: \n fourbar_slvs.7z  採用第一種作法。', 'tags': '', 'url': 'w8.html'}, {'title': 'Blender', 'text': 'Blender Manual  ( Reference ) \n camp_blender.pdf \n Add - Mesh - UV Sphere \n select + S - scale object \n select + G - move object \n select + Material property - Viewport display - change object color \n 按住滑鼠中鍵後移動 - rotate \n Shift + 按住滑鼠中鍵後移動 - pan \n Blender Hot keys  ( blender-4-shortcuts-hotkeys.pdf ) \n', 'tags': '', 'url': 'Blender.html'}, {'title': 'Webots', 'text': '具有網頁介面的開源3D機器人模擬器 \n 專案概述 \n \n 一家瑞士公司正在開發一個現實的機器人模擬器，可用於模擬涉及移動機器人、機器人手臂、無人機、自主車輛、工業過程等的數字雙胞胎場景。該軟體是開源的，基於桌面並具有基於雲的3D網頁介面。 \n 專案目標 \n 該模擬器可建模傳感器和執行器（如攝像頭、激光雷達、激光測距儀等），並允許機器人由處理傳感器數據的 AI算 法控制。 \n 詳細描述 \n 該中小企業開發了 Webots 軟體，一個開源的多平台桌面應用，用於模擬機器人。它提供了一個完整的開發環境來建模、編程和模擬機器人。Webots 用於工業、教育和研究，並自 1998 年以來一直維護。該軟體最初由瑞士洛桑聯邦理工學院（EPFL）開發。 \n Webots 支持創建機器人原型、開發、測試和驗證 AI 和控制算法，以及教學機器人學。用戶可以使用 Webots 的資產庫設計模擬，導入 CAD 模型，並使用 OpenStreetMap 地圖。 \n 圖形用戶介面支持編輯模擬和機器人控制器，節省開發時間。用戶可以創建各種機器人和環境的模擬，包括室內和室外。數字雙胞胎模型允許在模擬中測試改進，然後在真實系統中實施，提升溝通、探索和開發效率。 \n 技術信息 \n Webots 結合了圖形用戶介面（基於 Qt 庫）、物理引擎（基於 Open Dynamics Engine 的分支）和 3D 渲染引擎（OpenGL 3.3）。它運行於 Windows、Linux 和 macOS。模擬可以導出為電影、互動 HTML 場景、動畫，甚至在線流式傳輸。機器人可以使用 C、C++、Python、Java、MATLAB 或 ROS 編程，使用簡單的 API 覆蓋所有基本的機器人需求。 \n 網頁介面位於  Webots Cloud ，允許在雲中運行模擬、播放 3D 動畫並展示場景和物體。 \n 優勢與創新 \n \n 高質量的免費開源技術，用於模擬機器人系統。 \n 輕鬆導出模擬、3D 動畫和模型，以便與其他人分享。 \n 來自瑞士中小企業的專家支持，並提供定制開發服務。 \n 利用 Webots 用戶社區的貢獻，包括機器人、傳感器、執行器、物體、環境、基準測試、控制程序等模型。 \n 通過  Webots Cloud Competition  輕鬆組織機器人挑戰和編程競賽。 \n \n Analysis_exploring_risks_and_opportunities_linked_to_the_use_of_collaborative_industrial_robots_in_Europ.pdf \n Webots project:\xa0 https://www.rosin-project.eu/ftp/ros2-for-the-e-puck2-robot \xa0', 'tags': '', 'url': 'Webots.html'}, {'title': 'Deepbots', 'text': 'Deepbots: A Webots-Based Deep Reinforcement Learning Framework for Robotics \n 概要 \n Deepbots 是一個開源框架，結合了  OpenAI Gym  介面和 Webots 機器人模擬器，以標準化方式在各種機器人場景中應用深度強化學習（DRL）。該框架旨在減少開發工作量，讓研究人員能夠輕鬆地在 Webots 中開發 DRL 方法。本文通過代碼示例和三個難度不同的案例展示了該框架的有效性。 \n 主要貢獻 \n \n 提供一個易於使用的 DRL 介面，結合 OpenAI Gym 和 Webots。 \n 簡化了 DRL 方法的開發，處理了低層細節。 \n 提供即用型標準化環境和額外的監控工具（如 tensorboard 日誌和繪圖）。 \n \n 重要特點 \n \n Webots : 專業的 3D 機器人模擬器，支持多種機器人和傳感器。 \n OpenAI Gym : 標準化的 DRL 介面，提供經典的 agent-environment 循環。 \n Deepbots 框架 : 作為 Webots 和 DRL 算法之間的中介，提供多層次的抽象和高代碼可讀性及可重用性。 \n \n 相關工作 \n \n OpenAI Gym : 標準化 RL 測試環境，但僅限於簡單、不現實的場景。 \n Gazebo : 另一個流行的機器人模擬器，但圖形質量較低。 \n Isaac Gym : 提供照片真實渲染和平行處理，但為閉源軟件。 \n \n Deepbots 架構 \n \n Supervisor Controller : 監督者控制器，負責從環境中獲取觀察並與 agent 交流。 \n Robot Controller : 機器人控制器，負責從傳感器讀取數據並執行動作。 \n 通信機制 : 使用發射器和接收器進行消息傳遞。 \n \n 案例環境 \n \n CartPole : 維持倒立擺垂直，使用  PPO 算法 。 \n Pit Escape : BB-8 機器人從坑中逃脫，使用  PPO 算法 。 \n Find the Ball and Avoid Obstacles : E-puck 機器人找到目標並避開障礙物，使用  DDPG 算法 。 \n \n 結論 \n Deepbots 為想在高保真模擬器 Webots 中應用 RL 和 DRL 的研究人員提供了一個標準化的方法，適用於多種研究和教育用途。 \n 參考文獻 \n 提供了一系列相關文獻和資源鏈接，包括 OpenAI Gym、Gazebo、Isaac Gym 等。 \n Deepbots 框架的源代碼和更多信息可在  GitHub  上找到。 \n', 'tags': '', 'url': 'Deepbots.html'}, {'title': 'task6', 'text': 'Webots Tutorial 4 ~6 (HW3) \n \n', 'tags': '', 'url': 'task6.html'}, {'title': 'Homework', 'text': '作業 (30%) \n HW1 (5%):  建立由 Box 組成的平面四連桿機構 Webots 模擬場景 \n part1: \n 請各學員在 USB 隨身碟或個人電腦上完成 cd2025 課程所需的可攜系統配置: \n 下載  portable_wcm2025.7z  (330MB, 解開壓縮後 1.4GB) \n Webots_2025a.7z  (1.5 GB, 解開後約為 2.9GB, 可單獨運作) \n Webots_2025a_web.7z  (171 MB, 解開壓縮後約為 1GB, 必須連網運作) \n Blender4.2.7z \n part2: \n 請各學員完成可攜程式系統配置後, 利用 Webots R2025a 中寬度與高度都為 0.1m 的 box 物件建立一個簡單的平面四連桿機構模擬場景. \n base (基座) 長度 1m, link1 長度 0.4m, link2 長度 0.6m, link3 長度 0.9m, 各轉軸均為 HingeJoint, joint1 旋轉速度設定為 1radian/sec. \n part3: \n 模擬場景啟動後, 按下 s 鍵機構開始作動, 按下 p 鍵後機構暫停. \n 參考資料: \n cd2025_hw1_demo.7z \n HW2 (5%):  建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景 \n 各學員請利用 CAD 系統依據 HW1 的連桿尺寸與運動方式, 配置適當大小的旋轉軸以及基座後, 利用 Webots R2025a 完成一個簡單的平面四連桿機構模擬場景. \n 參考資料: \n fourbar_slvs.7z \n HW3 (20%): 建立 Webots 桌上籃球遊戲機模擬系統 \n 請各分組利用CAD 系統建立一個能在電腦桌 (1600W X 700D X 740H mm) 上運作的投籃機構 ( 參考影片 )後, 導入 Webots R2025a 套件, 建立一個能由使用者透過鍵盤按鍵操作, 且具備計分板的籃球遊戲機模擬系統. \n 參考資料: \n 參考資料: \n fourbar_ball_throwing_linkage.slvs \n sixbar_ball_throwing_linkage.slvs \n \n', 'tags': '', 'url': 'Homework.html'}, {'title': 'HW1', 'text': 'HW1 (5%):  建立由 Box 組成的平面四連桿機構 Webots 模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW1 - 學員學號 \n \n 以下將利用 box 幾何外形節點建立平面四連桿機構的模擬場景, 要求地面固定桿長度 1m, 寬高各為 0.1m, 第一桿長度 0.4m, 第二桿長度 0.6m, 第三桿長度 0.9m. \n Step1:  在可攜程式套件中開啟 Webots, 也就是在 cmd 視窗中輸入 webotsw 就可以開啟套件, 但安裝 Windows 的電腦必須符合 硬體規格的要求 . \n Step2:  Webots 啟動後, 可以利用下拉式功能表 File - New - New Project Directory, 選擇 Y:\\tmp\\hw1 作為專案目錄, 建立 hw1.wbt, 其中因為不需要設置地板, 因此 Add a rectangle arena 選項可以不用勾選. \n Step3:  若模擬已經開始, 請按下 Pause the simulation 或透過 Ctrl + 0 暫停模擬, 並且利用 Reset simulation 或透過 Ctrl + Shift + t 讓模擬時間回到 t=0, 之後完成階段設定後, 必須讓模擬時間回到 t=0 之後才進行 hw1.wbt 的存檔. \n Step4:  確定 t=0 後, 按下 Save the current world file 或透過 Ctrl + Shift +s 儲存正在建立的 world 檔案, 之後利用 SciTE 開啟 Y:\\tmp\\hw1\\worlds\\hw1.wbt, 檔案內容如下: \n #VRML_SIM R2025a utf8\n\nEXTERNPROTO "https://raw.githubusercontent.com/cyberbotics/webots/R2025a/projects/objects/backgrounds/protos/TexturedBackground.proto"\nEXTERNPROTO "https://raw.githubusercontent.com/cyberbotics/webots/R2025a/projects/objects/backgrounds/protos/TexturedBackgroundLight.proto"\n\nWorldInfo {\n}\nViewpoint {\n  orientation -0.5773502691896257 0.5773502691896257 0.5773502691896257 2.0944\n  position 0 0 10\n}\nTexturedBackground {\n}\nTexturedBackgroundLight {\n}\n \n 其中第一行表示此 .wbt 採用 R2025a 所建立, 其格式為 VRML_SIM 模擬語法, 且檔案採用 utf8 編碼. \n 之後則從官方網站取得 TexturedBackground.proto 與 TexturedBackgroundLight.proto 原型節點, 並宣告 Viewpoint 所在的點座標以及方位. \n Step5:  利用 Add a new object or import an object (or Ctrl + Shift + a) 從 Base nodes 類別中, 選擇建立一個 Robot 節點. 這時假如確定 t=0 按下儲存 hw1.wbt, 則模擬場景將在上述檔案中加上: \n Robot {\n} \n Step6:  由於先前在執行  Tutorial2  時, 已經知道要建立一個簡單的剛體, 如下圖所示, 必須先建立 Solid 節點, 然後再依序建立運動模擬用的 Shape、碰撞檢測用的 boundingObject 以及物理特性參數. \n \n 因此在 Robot 節點下的 children 先建立一個 Solid 節點, 且命名 (DEF) 為 base, 此 Solid 的 name 欄位也設為 base,\xa0 而此節點就是用來模擬長度 1m, 寬高各為 0.1m 的固定連桿 (base). 並在 Solid 節點下的 children 建立一個 Shape, 且將此 Shape 命名為 base_shape. 之後將 base_shape 下的 geometry 節點中加入 box 節點. \n 此時內建的視圖為 Top View, 但並未顯示出全域座標系統, 可以利用 View - Optional Rendering - Show coordinate system 列出座標系統, 透過上視圖可以發現, x 座標向右為正, 而 y 座標則向上為正. 為了取得長 1m 的固定桿外形, 因此在上述 box x 方向欄位從內定的 0.1m 改為 1m, 即完成固定桿幾何外形的設定. \n 接著確定 t=0 的狀態下儲存檔案, hw1.wbt 的 Robot 場景內容如下: \n Robot {\n  children [\n    DEF base Solid {\n      children [\n        DEF base_shape Shape {\n          geometry Box {\n            size 1 0.1 0.1\n          }\n        }\n      ]\n      name "base"\n    }\n  ]\n} \n 從上列 hw1.wbt 可以發現除了 children 節點欄位使用 [] 外其餘欄位均以 {} 界定, 其差別為 [] 類似數列, 可以納入多個相同節點物件, 而採 {} 界定的欄位內則各參數設定並不會重複. (AI 詢問提詞: webots 中 .wbt [] 與 {} 有何差別?) \n 由於在定義 Shape 節點時已經將其 DEF 為 base_shape (DEF 為 Define 定義的意思), 之後可以在設定 boundingObject 碰撞檢測用的 geometry, 利用 USE 重用此一個 Shape 節點外形. 設定完成後 hw1.wbt 成為: \n Robot {\n  children [\n    DEF base Solid {\n      children [\n        DEF base_shape Shape {\n          geometry Box {\n            size 1 0.1 0.1\n          }\n        }\n      ]\n      name "base"\n      boundingObject USE base_shape\n    }\n  ]\n}\n \n Step7:  由於 base 物件為 static, 也就是設定為不會移動的物體, 因此無需設定密度與質量等 physics 物理特性. 但在 base 物件上總共會設定兩個旋轉軸, 其一為主動軸 joint1 與被動軸 joint4. \n 在 Webots 機電模型上, 物體上的轉動軸、移動軸或球接軸都必須與配置其上的物體在相同位階 (與 CoppeliaSim joint 設為子階的作法不同). \n 因此在建立 joint1 時, 可以將滑鼠停在 base Solid 節點上, 然後新增一個 HingeJoint, DEF 為 joint1. 之後再新增一個 HingeJoint, DEF 為 joint4. \n Step8:  點開 DEF joint1 HingeJoint 節點後, 其下有兩個用藍色圓形 icon 代表的"節點", 以及一個用棕色方形 icon 代表的"欄位". \n HingeJoint 其下的兩個節點名稱分別為 jointParameters 以及 endPoint, 初始對應物件都是 NULL, 代表沒有設定. 而欄位的名稱為 device, 可以加入煞車 (brake)、感測器 (sensor) 或致動器 (actuator) 等裝置. \n 首先雙點擊 jointParameters 節點, 以便加入節點參數, 其中包括指定 joint1 的 axis 向量以及旋轉中心座標 (即 anchor). \n 接著雙點擊 device 欄位, 以便加入 RotationalMotor, 且將其 name 設定為 motor1. \n 最後可以透過雙點擊 endPoint 欄位 (, 準備加入接在 joint1 上的 link1, 但是考量到設計標的中的 link1 是以 base 左端點座標旋轉, 但並非以該 link1 的中心點旋轉, 而是以 link1 的連桿端點旋轉, 因此當在 endPoint 建立 link1 所需的 Solid 節點之後, 除了 endPoint 所在的座標系統外 (該系統原點為 link1 的中心點), link1 還需要進行座標移動才能達成標的中的 link1 位置. \n 所以在 endPoint 從 NULL 改設定為 Solid 之後, 再接著建立 link1 所需的 Shape 節點之前, 必須先建立  Pose  節點, 以便在 link1 中心移動到 base 物件左邊端點之後, 再利用其 parent 節點  Pose  進行物件移動. \n 所以操作步驟如下: \n 雙點擊 endPoint 節點, 建立一個 Solid 節點 (因為準備將 link1 剛體接在 joint1 的旋轉端點上), DEF 設為 link1, 並在 Solid 的 children 節點上, 先建立一個  Pose  節點, 然後在  Pose  節點的 children 上再建立屬於 link1 的 Shape 節點. 並將此 Shape 節點 DEF 為 link1_shape 後, 於 geometry 節點處加入 box 節點. \n 此時需要在場景中 show 出系統的座標系統, 以便用來設定 box 的尺寸, 因此透過下拉式功能表 View - Optional Rendering - Show Coordinate System 顯示出系統的座標系統. \n 將 link1 的 Shape 幾何外形 box 尺寸設為 (0.4, 0.1, 0.1), 也就是 x 方向長度 0.4m, y 與 z 方向長度為 0.1m \n 接著雙點擊 geometry Box 上方的 apperance 節點, 加入一個 Apperance 節點, 也就是所謂的物件外觀節點, 並在外觀節點的 apperance 節點上加入一個 Apperance 節點, 並在 material 節點加入 Material 節點. 如此便可以利用 Material 節點中的 diffuseColor 欄位設定 RGB 欄位中的顏色比例值. 最後請將 link1 外觀顏色設為紅色 (RGB: 1.0, 0, 0) \n Step9:  從下列場景的樹狀結構, 可以發現 Robot、base 與 joint1 所依據的座標系統都相同, 且位於 base link 的中心點. 此時在 joint1 的 endPoint 欄位加入 link1 Solid 之後, 其座標原點也是位於 base link 的中心點, 由於 link1 必須移動至 base link 的左邊端點, 而 joint1 的旋轉中心點座標與旋轉向量, 則可以透過 jointParameters 中的 anchor 與 axis 欄位進行設定. \n \n 控制程式: \n from controller import Robot, Keyboard\n\ndef run_robot():\n    # Create the Robot instance\n    robot = Robot()\n    \n    # Get simulation time step\n    timestep = int(robot.getBasicTimeStep())\n    \n    # 初始化鍵盤，並設定取樣時間為 timestep\n    keyboard = Keyboard()\n    keyboard.enable(timestep)\n\n    # Get motor device\n    motor = robot.getDevice(\'motor1\')\n\n    # Set motor for continuous rotation\n    motor.setPosition(float(\'inf\'))\n    # 初始設定馬達速度為 0 (暫停狀態)\n    motor.setVelocity(0.0)\n    \n    # 設定一個變數來追踪馬達是否在運行\n    is_running = False\n    \n    print("模擬開始. 按下 \'s\' 啟動馬達, 按下 \'p\' 暫停.")\n\n    # Main control loop\n    while robot.step(timestep) != -1:\n        # 取得鍵盤輸入\n        key = keyboard.getKey()\n        \n        # 將 key 轉換為對應的字符\n        key_char = chr(key).lower() if key != -1 else \'\'\n        \n        # 使用字符直接比較\n        if key_char == \'s\':\n            is_running = True\n            motor.setVelocity(1.0)\n            print("馬達啟動")\n            \n        elif key_char == \'p\':\n            is_running = False\n            motor.setVelocity(0.0)\n            print("馬達暫停")\n\nif __name__ == "__main__":\n    run_robot() \n hw1.7z \n w6_2a_hw1.7z  (課堂上 demo, base 連桿利用 material - Material - transparency 設為 1 隱藏, 其餘各 links 的 physics 與 boundingObject 均要具備, 且 joint4 的 anchor (旋轉中心點) 與 axis (旋轉軸向量) 也要指定) \n', 'tags': '', 'url': 'HW1.html'}, {'title': 'Tutorial1', 'text': 'https://cyberbotics.com/doc/guide/tutorial-1-your-first-simulation-in-webots \n Tutorial 1: Your First Simulation in Webots (30 Minutes) \n The objective of this first tutorial is to familiarize yourself with the user interface and with the basic concepts of Webots. You will create your first simulation containing a simple environment: an arena with floor and walls, a few boxes, an e-puck robot and a controller program that will make the robot move. \n 第一個教學導引的目的, 是讓使用者熟悉 Webots 的使用者介面與基本概念. 如下圖所示, 此導引所創建的模擬場景包含一個簡單的場景: 帶有地板與圍牆的競技場、幾個箱子、一個 e-puck 機器人和一個能控制機器人移動的程式. \n \n What you should see at the end of the first tutorial. \n \n Index \n \n Start Webots \n Create a New World \n Add an e-puck Robot \n Create a New Controller \n Extend the Controller to Speed Control \n Conclusion \n \n Start Webots \n If not already done, download and install Webots, following these  installation instructions . \n \n Hands-on #1 :  Start Webots  by double-clicking on its icon (or invoking it from a command line in a Terminal). If you are running Webots for the first time on this computer, you may be prompted to select a graphical theme. You may also be invited to follow the Webots guided tour, go ahead and close the guided tour. \n \n If you never saw it, please take some time to view the demos featured in the guided tour. They are telling a lot about the possibilities of Webots. The guided tour is also available from the  Help  menu of Webots. \n Create a New World \n A  World  is a file containing information like where the objects are, what they look like, how they interact with each other, what is the color of the sky, and the definitions of gravity, friction, masses of the objects, etc. It defines the initial state of a simulation. The different objects are called  Nodes  and are organized hierarchically in a  Scene Tree . Therefore, a node may contain sub-nodes. A world is stored in a file having the  .wbt  extension. The file format is derived from the  VRML97  language, and is human readable. The world files must be stored directly in a directory called  worlds . \n 這裡所謂的 World 是一個文件檔案, 其中包含物件所在位置、外觀、以及如何與環境及其他物件進行相互作用、天空的顏色與重力、摩擦力、物件質量等資訊. 此外, 文件中還定義了模擬的初始狀態. \n 模擬場景中的各個物件稱為節點, 採樹狀架構排列. 其中的節點可以包含子節點. 模擬場景的檔案副檔名為 .wbt, 也就是 webots 中取 wbt 三個字母所組成. 該文件格式源自 VRML97 語言, 內容為明碼, 可以直接由文字編輯器讀取或編輯. 模擬場景檔案則規定必須儲存在名稱為 worlds 的目錄中. \n \n Hands-on #2 : Pause the current simulation by clicking on the  Pause  button   of the 3D view (see the  user interface description  to find out the buttons). The simulation is paused if the virtual time counter on the main toolbar is stopped. Create a new project from the  File / New / New Project Directory...  menu item and follow the instructions: \n \n Name the project directory  my_first_simulation  instead of the proposed  my_project . \n Name the world file  my_first_simulation.wbt  instead of the proposed  empty.wbt . \n Click all the tick boxes, including the "Add a rectangle arena" which is not ticked by default. \n \n \n Webots displays a list of directories and files it just created. This corresponds to the  standard file hierarchy of a Webots project . Click on the  Finish  (Windows, Linux) or  Done  (macOS) button to close this window. \n Congratulations, you just created your very first Webots world! The 3D view should display a square arena with a checkered floor. You can move the viewpoint in the 3D view  using the mouse : left button, right button and the wheel. \n Webots nodes stored in world files are organized in a tree structure called the  scene tree . The scene tree can be viewed in two sub-windows of the main window: the  3D view  (at the center of the main window) is the 3D representation of the scene tree and the  scene tree view  (on the left) is the hierarchical representation of the scene tree. The  scene tree view  is where the nodes and fields can be modified. It should currently list the following nodes: \n \n WorldInfo : contains global parameters of the simulation. \n Viewpoint : defines the main viewpoint camera parameters. \n TexturedBackground : defines the background of the scene (you should see mountains far away if you rotate a little bit the viewpoint) \n TexturedBackgroundLight : defines the light associated with the above background. \n RectangleArena : define the only object you see so far in this scene. \n \n Each node has some customizable properties called  Fields . Let\'s modify these fields to change the rectangle arena: \n 每一個節點都帶有可以自行設定的屬性稱為欄位. \n \n Hands-on #3 : Double-click on the  RectangleArena  node in the scene tree. This should open the node and display its fields. (雙點擊各節點可以帶出其特定的欄位) \n \n Select the  floorTileSize  field and set its value to  0.25 0.25  instead of  0.5 0.5 . You should see the effect immediately in the 3D view. \n Select the  wallHeight  field and change its value to  0.05  instead of  0.1 . The wall of the arena should now be lower. \n \n \n In the  scene tree view , the fields are displayed in a different color (depending on the theme) if they differ from their default values. Now, we would like to add some objects: \n 當欄位值與其內定值不同時, 將以不同的顏色進行標示. \n 按下 shift+滑鼠左鍵, 可以移動物件. \n 選擇物件後, 可以用 Ctrl + C 複製該物件, 然後以 Ctrl + V 貼上該複製的物件, 然後再利用 Ctrl + 滑鼠左鍵移動物件. \n 選擇物件後, 出現位於物件中心點的座標向量與旋轉標示, 可以用滑鼠點選後可以利用向量進行單一方向的移動或利用旋轉標示旋轉物件. \n \n Hands-on #4 : Double-click on the  RectangleArena  in the scene tree to close it and select it. Click on the  Add  button   at the top of the scene tree. In the open dialog box, choose  PROTO nodes (Webots Projects) / objects / factory / containers / WoodenBox (Solid) . A big box should appear in the middle of the arena. Double-click on it in the scene tree to open its fields. \n \n Change its  size  to  0.1 0.1 0.1  instead of  0.6 0.6 0.6 . \n Change its  translation  to  0 0 0.05  instead of  0 0 0.3 . Alternatively, you may use the blue arrow that appears in the 3D view to adjust its  translation.z  field. \n Now shift-click and drag the box in the 3D view and move it in some corner of the arena. \n Select the box and press  ctrl - C ,  ctrl - V  (Windows, Linux) or  ⌘ command - C ,  ⌘ command - V  (macOS) to copy and paste it. Shift-click and drag the new box to move it at some different location. Create a third box this way. \n Move the boxes, so that no box is at the center of the arena. You may also use the blue rotation arrows to rotate the boxes along the vertical axis. This can be done also by shift-click and drag with the right mouse button. Alternatively, you can change the angle of the  rotation  field of the  WoodenBox  nodes in the scene tree. \n Once you are satisfied with the result, save the world using the save button. \n \n \n Using the translation and rotation handles to move objects is explained in  this section . \n Add an e-puck Robot \n The e-puck is a small robot having differential wheels, 10  LEDs , and several sensors including 8  DistanceSensors  and a  Camera . In this tutorial we are only interested in using its wheels. We will learn how to use other capabilities in the next tutorials. \n Now, we are going to add an e-puck model to the world. Make sure that the simulation is paused and that the virtual time elapsed is 0. If this is not the case, reset the simulation with the  Reset  button  . \n When a Webots world is modified with the intention of being saved, it is fundamental that the simulation is first paused and reloaded to its initial state, i.e. the virtual time counter on the main toolbar should show 0:00:00:000. Otherwise at each save, the position of each 3D object can accumulate errors. Therefore, any modification of the world should be performed in that order:  pause, reset, modify and save the simulation . \n We don\'t need to create the e-puck robot from scratch, we will just have to import a  E-puck  node. This node is actually a  PROTO  node, like the  RectangleArena  or the  WoodenBox  we introduced before. Prototyping allows you to create custom objects and to reuse them. \n \n Hands-on #5 : Select the last node  WoodenBox  of the scene tree view. Click on the  Add  button   at the top of the scene tree view. In the dialog box, choose  PROTO nodes (Webots Projects) / robots / gctronic / e-puck / E-puck (Robot) . An e-puck robot should appear in the middle of the arena. Move and rotate this robot, the same way you did it with the boxes. Save the simulation and press the  Run real-time  button  . \n \n The robot should move, blink LEDs and avoid obstacles. That\'s because it has a default controller with that behavior. You may have noticed a small black window appearing in the upper-left corner of the 3D view. It shows the image taken by the  Camera  of the e-puck robot. This image will remain black until the camera is explicitly enabled by the controller of the robot. This small image window can be  moved  around by dragging it. It can also be  resized  by dragging the bottom-right corner. Finally, it can be closed by clicking the "x" in the top-right corner. You can make it visible again from the  Overlays  menu, by selecting it in the  Camera Devices  submenu. Because we won\'t need it, you can actually close it. \n Now, while the simulation is running, let\'s play with the physics: \n \n Hands-on #6 :  Apply a force  to the robot by pressing  alt   + left-click + drag  (use the  ⌥ option  key on some Mac keyboards). On Linux, you should also press the  ctrl  key in addition to  alt   + left-click + drag . It is not possible to apply a force to a  WoodenBox  node, because by default, they have no mass and are considered as glued on the floor. To enable physics on the  WoodenBox  nodes, you should set their  mass  field to a certain value (for example 0.2 kg). Once this is done, should be able to apply a force on them as well. \n \n The simulation may be paused  , run step-by-step  , in real time   or in fast   modes. \n Now we are going to modify the world and decrease the step of the physics simulation: this will increase the accuracy and stability of the simulation (but reduce the maximum simulation speed). \n \n Hands-on #7 : Pause the simulation and revert it. In the Scene Tree view, expand the  WorldInfo  node (the first node). Set its  basicTimeStep  field to  16 . Then save the simulation. \n \n Create a New Controller \n We will now program a simple controller that will just make the robot move forwards. \n A  controller  is a program that defines the behavior of a robot. Webots controllers can be written in the following programming languages: C, C++, Java, Python, MATLAB, etc. C, C++ and Java controllers need to be compiled before they can be run as robot controllers. Python and MATLAB controllers are interpreted languages so they will run without being compiled. In this tutorial, we are going to use C as a reference language but all the code snippets are also available in C++, Java, Python and MATLAB. Refer to the  language chapter  to setup a controller using a different programming language. \n The  controller  field of a  Robot  node specifies which controller is currently associated to the robot. Note that the same controller can be used by several robots, but a robot can only use one controller at a time. Each controller is executed in a separate child process usually spawned by Webots. Because they are independent processes, controllers don\'t share the same address space, and may run on different processor cores. \n \n Hands-on #8 : Create a new C (or any other language) controller called  epuck_go_forward  (for C++ and Java call it  EPuckGoForward  instead) using the  File / New / New Robot Controller...  menu item. This will create a new  epuck_go_forward  (or  EPuckGoForward ) directory in  my_first_simulation/controllers . Select the option offering you to open the source file in the text editor. \n \n The new source file is displayed in Webots text editor window. This source file may be compiled (if written in C, C++ or Java) without any modification, however the current code has no real effect. We will now associate new  epuck_go_forward  (or  EPuckGoForward ) controller to the  E-puck  node. \n \n \n \n Hands on #9 : In the scene tree view, select the  controller  field of the  E-puck  node, then use the field editor at the bottom of the Scene Tree view: press the  Select...  button and then select  epuck_go_forward  in the list. Once the controller is associated with the robot, save the world. Modify the program by getting the motor devices ( leftMotor = robot.getDevice(\'left wheel motor\') ), and by applying a motor command ( leftMotor.setPosition(10.0) ): \n from controller import Robot, Motor\n\nTIME_STEP = 64\n\n# create the Robot instance.\nrobot = Robot()\n\n# get the motor devices\nleftMotor = robot.getDevice(\'left wheel motor\')\nrightMotor = robot.getDevice(\'right wheel motor\')\n# set the target position of the motors\nleftMotor.setPosition(10.0)\nrightMotor.setPosition(10.0)\n\nwhile robot.step(TIME_STEP) != -1:\n   pass\n \n Save the modified source code ( File / Save Text File ), reset and run the simulation. \n \n \n If everything is fine, your robot should move forwards. The robot will move using its maximum speed for a while and then stop once the wheels have rotated of 10 radians. \n In the  controllers  directory of your project, a directory containing the  epuck_go_forward  (or  EPuckGoForward ) controller has been created. The  epuck_go_forward  (or  EPuckGoForward ) directory contains a  epuck_go_forward  (or  EPuckGoForward ) binary file generated after the compilation of the controller (on Windows, this file has the  .exe  extension). The controller directory name should match with the binary name. \n Extend the Controller to Speed Control \n The robots wheels are often controlled using velocity, and not position like we did in the previous example. In order to control the motors of the wheels in speed you need to set the target position to the infinity and to set the desired speed: \n \n \n \n Hands-on #10 : Modify the controller program as shown below, recompile it and run it: \n from controller import Robot, Motor\n\nTIME_STEP = 64\n\nMAX_SPEED = 6.28\n\n# create the Robot instance.\nrobot = Robot()\n\n# get a handler to the motors and set target position to infinity (speed control)\nleftMotor = robot.getDevice(\'left wheel motor\')\nrightMotor = robot.getDevice(\'right wheel motor\')\nleftMotor.setPosition(float(\'inf\'))\nrightMotor.setPosition(float(\'inf\'))\n\n# set up the motor speeds at 10% of the MAX_SPEED.\nleftMotor.setVelocity(0.1 * MAX_SPEED)\nrightMotor.setVelocity(0.1 * MAX_SPEED)\n\nwhile robot.step(TIME_STEP) != -1:\n   pass \n \n \n The robot will now move (the wheels will rotate at a speed of 0.2 radian per second) and never stop. If nothing happens, don\'t forget to compile your code by selecting the  Build / Build  menu item or clicking on the gear icon   above the code area. Compilation errors are displayed in red in the console. If there are any, fix them and retry to compile. Then, reload the world. \n Conclusion \n We hope you enjoyed creating your first Webots simulation. You have been able to set up a world, add a robot and program it. The important thing is that you learned the fundamental concepts summarized below: \n \n A world is made up of nodes organized in a tree structure. \n A world is saved in a  .wbt  file stored in a Webots project. \n The project also contains the robot controller programs which define the behavior of the robots. \n Controllers may be written in C or other languages. \n C, C++ and Java controllers have to be explicitly compiled before they can be executed. \n Controllers are associated with robots via the  controller  fields of the  Robot  node. \n \n', 'tags': '', 'url': 'Tutorial1.html'}, {'title': 'HW2', 'text': 'HW2 (5%):  建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW2 - 學員學號 \n \n', 'tags': '', 'url': 'HW2.html'}, {'title': 'HW3', 'text': 'HW3 (20%): 建立 Webots 桌上籃球遊戲機模擬系統 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW3 - 學員學號 \n \n', 'tags': '', 'url': 'HW3.html'}, {'title': 'Midterm', 'text': '本課程所繳交的期中成績為學員自評之學習期望成績. \n 期中考週的自評期望成績繳交流程: \n \n 整理先前所完成的各週的進度、作業網頁內容以及心得 \n 拍攝期中自評影片, 上傳至 Youtube 後, 以" 國立虎尾科技大學 - 機械設計工程系 - cd2025 期中自評- 學員學號 "為影片標題後嵌入本頁面中 \n 回填期中自評表單 \n 上傳學員期中成績 \n \n 各週進度: \n 各週網頁內容: \n 期中心得: \n 期中自評影片: \n \n \n', 'tags': '', 'url': 'Midterm.html'}, {'title': 'Exam', 'text': 'Exam1 (10%): 建立 Webots 基本物件模擬場景 \n 各學員利用 Webots R2025a 套件中的 Shape 物件, 隨堂建立指定的機電系統模擬場景, 並利用 Python 程式進行互動控制. \n Exam2 (10%): 利用 CAD 零組件建立模擬場景\xa0 \n 各學員利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制. \n Exam3 (20%): Webots 機電模擬場景的協同設計 \n 各分組利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制. 過程中各學員必須採同步協同模式, 維護從 Github Classroom 取得的分組協同倉儲以及網站. \n 協同分組方式: \n \n 分配學員負責利用 Solvespace 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁. \n 分配學員負責利用 NX2312 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁. \n 分配學員負責利用 Webots 建立機電系統模擬場景, 並利用 Python 程式進行控制, 過程中必須將建構過程拍成帶有說明字幕的影片上傳至分組網頁. \n \n', 'tags': '', 'url': 'Exam.html'}, {'title': 'Exam1', 'text': 'Exam1 (10%): 建立 Webots 基本物件模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam1 - 學員學號 \n', 'tags': '', 'url': 'Exam1.html'}, {'title': 'Exam2', 'text': 'Exam2 (10%): 利用 CAD 零組件建立模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam2 - 學員學號 \n', 'tags': '', 'url': 'Exam2.html'}, {'title': 'Exam3', 'text': 'Exam3 (20%): Webots 機電模擬場景的協同設計 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam3 - 學員學號 \n', 'tags': '', 'url': 'Exam3.html'}, {'title': 'Final', 'text': '期末協同專案執行過程影片、簡報與 PDf 報告檔案 (六人一組) (30%) \n 題目:  Webots 動態投籃模擬系統的協同設計 \n 說明:  \n 籃框架被配置在一定範圍內, 可隨機慢速前進、後退及左右擺動, 投籃機構系統帶有一定數量的籃球, 被配置在可自由移動的輪車上. \n 操作者可利用鍵盤特定按鍵控制投籃輪車的移動並發射投籃, 每投出一球後系統透過記分板進行計分, 並由送球機構進行補球或移動輪車取球, 遊戲可進行至全部數量籃球投完為止. \n 請將期末協同專案執行過程、內容與心得, 製作成影片，配合字幕上傳至 Youtube 後嵌入各階段的期末報告頁面中. \n 影片標題:  國立虎尾科技大學 - 機械設計工程系 - cd2025 期末報告 - 學員學號 - 各階段影片主題 \n', 'tags': '', 'url': 'Final.html'}, {'title': 'Brython', 'text': '1 add to 100 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': 'Brython.html'}]};